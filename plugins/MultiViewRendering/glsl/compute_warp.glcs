#version 460 core

layout (local_size_x = 16, local_size_y =16) in;

uniform sampler2D color_tex0;
uniform sampler2D depth_tex0;
uniform sampler2D color_tex1;
uniform sampler2D depth_tex1;
uniform sampler2D color_tex2;
uniform sampler2D depth_tex2;

uniform mat4 p_source_zero;		// arbitrary projection matrix from one view

uniform float start_x;			// x-coordinate in eye coordinates where the leftmost view lies
uniform float x_offset;			// the difference in x-coordinates between two views in eye coordinates
uniform float z_far;			// (positive) depth at z-far plane
uniform float shear;			// offset due to shear of the different projection matrices
uniform float eye_sep;			// eye seperation between stereo eyes
uniform float zero_parallax;	// (positive) depth at zero parallax

uniform int screen_w;
uniform int screen_h;
uniform int quilt_cols;
uniform int nr_holo_views;
uniform int nr_render_views;

layout(std430, binding = 0) buffer storage_buffer
{
    uint col_depth[];
};

void main()
{  	
	ivec2 global_coord = ivec2(gl_GlobalInvocationID.xy);
	global_coord.x = clamp(global_coord.x, 0, screen_w-1);
	global_coord.y = clamp(global_coord.y, 0, screen_h-1);

	vec2 texcoord = vec2(global_coord.x/float(screen_w-1), global_coord.y/float(screen_h-1));

	vec4 color;
	float pt_depth;

	// iterate over all rendered views that are available
	for (int i = 0; i < nr_render_views; i++){
		//get color and depth values for the rendered views
		if (i == 0){
			color = textureLod(color_tex0, texcoord, 0);
			pt_depth = textureLod(depth_tex0, texcoord, 0).r;
		}
		else if (i==1){
			color = textureLod(color_tex1, texcoord, 0);
			pt_depth = textureLod(depth_tex1, texcoord, 0).r;
		}
		else{
			color = textureLod(color_tex2, texcoord, 0);
			pt_depth = textureLod(depth_tex2, texcoord, 0).r;
		}
		ivec4 color_bytes = ivec4(color * 255);

		// get source view data depending on the for-loop iteration
		float source_idx = nr_render_views == 1 ? 0.0 : (2.0f * i) / (nr_render_views - 1) - 1.0f;
		vec4 eye_source = vec4(- start_x * source_idx, 0, 0, 1);
		// calculate source view's projection source view's matrix
		mat4 p_source = p_source_zero;
		p_source[2][0] = -eye_sep * source_idx;
		p_source[3][0] = -zero_parallax * eye_sep * source_idx;

		// get the current point's position in eye space
		vec4 pt_eye_coord = inverse(p_source) * vec4(2*texcoord.x-1, 2*texcoord.y-1, 2*pt_depth-1, 1);
		vec4 pos_eye = vec4(pt_eye_coord.xyz/pt_eye_coord.w,1);

		for (int c = 0; c < nr_holo_views; c++){
			// calculate target position in eye coordinates
			vec4 eye_target = vec4(start_x + c*x_offset, 0, 0, 1);

			// calculate the intersection of the line from target view to the current point with the plane at z_far
			vec4 intersection_z_far = eye_target + (eye_target - pos_eye) * z_far / pos_eye.z;
			intersection_z_far.x -=  shear * (eye_target.x - eye_source.x);

			// calculate the intersection of the line from source view to the intersection at z_far with the plane at the current point's depth
			vec4 intersection_pt_depth = eye_source + (eye_source-intersection_z_far) * pos_eye.z / intersection_z_far.z;
		
			// reproject point to clip coordinates and calculate it's new window coordinates
			vec4 new_pos_clip = p_source * intersection_pt_depth;
			float x_window = 0.5*(new_pos_clip.x/new_pos_clip.w+1);

			// get the new position in coordinates [0,screen_width) with an offset depending on what view it is
			int y_index = c/quilt_cols;
			int x_index = c%quilt_cols;
			int new_pos_x = clamp(int(ceil((x_window+x_index) * screen_w - 1)),x_index*screen_w,(x_index+1)*screen_w-1);
			int index = new_pos_x+(global_coord.y+y_index*screen_h)*screen_w*quilt_cols;

			// push elements to the back that are outside of the view's window to eliminate artefacts at leftmost and rightmost pixel columns
			int depth = (x_window<0.0 || x_window>1.0) ? 127 : int(127*pt_depth);

			// assemble all data into a single 32 bit integer
			uint point = (depth << 25) | (int(color_bytes.a & 0x1)<<24) | (int(color_bytes.r) << 16) | (int(color_bytes.g) << 8) | int(color_bytes.b);
			uint old_point = col_depth[index];
			// early depth test
			if(old_point > point){
				// use atomicMin to keep the value with the smallest depth (z-buffer alternative)
				atomicMin(col_depth[index],point);
			}
		}
	}
}