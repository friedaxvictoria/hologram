#version 460 core

layout (local_size_x = 5, local_size_y =9) in;

uniform sampler2D color_tex0;
uniform sampler2D depth_tex0;
uniform sampler2D color_tex1;
uniform sampler2D depth_tex1;
uniform sampler2D color_tex2;
uniform sampler2D depth_tex2;

uniform mat4 p_source_zero;

uniform float start_x;
uniform float x_offset;

uniform float z_far;
uniform float shear;
uniform float eye_sep;
uniform float zero_parallax;

uniform int screen_w;
uniform int screen_h;
uniform int quilt_cols;
uniform int nr_holo_views;
uniform int nr_render_views;

layout(std430, binding = 0) buffer storage_buffer
{
    uint col_depth[];
};

void main()
{  	
	ivec2 global_coord = ivec2(gl_GlobalInvocationID.xy);
	vec2 texcoord = vec2((global_coord.x%screen_w)/float(screen_w-1), (global_coord.y%screen_h)/float(screen_h-1));

	int x_index = int(global_coord.x/float(screen_w));
	int current_view = x_index + int(global_coord.y/float(screen_h))*quilt_cols;
	vec4 eye_target = vec4(start_x + current_view*x_offset, 0, 0, 1);

	vec4 color;
	float pt_depth;

	// iterate over all rendered views that are available
	for (int i = 0; i < nr_render_views; i++){
		//get color and depth values for the rendered views
		if (i == 0){
			color = textureLod(color_tex0, texcoord, 0);
			pt_depth = textureLod(depth_tex0, texcoord, 0).r;
		}
		else if (i==1){
			color = textureLod(color_tex1, texcoord, 0);
			pt_depth = textureLod(depth_tex1, texcoord, 0).r;
		}
		else{
			color = textureLod(color_tex2, texcoord, 0);
			pt_depth = textureLod(depth_tex2, texcoord, 0).r;
		}
		// if point is too far away, set alpha to zero so it's not visible in the end
		color.a = (pt_depth >= 1.0) ? 0 : color.a;
		// combine color and depth information for storing it in the storage buffer
		ivec4 color_bytes = ivec4(color * 255);

		// get source view data depending on the for-loop iteration
		float source_idx = nr_render_views == 1 ? 0.0 : (2.0f * i) / (nr_render_views - 1) - 1.0f;
		vec4 eye_source = vec4(- start_x * source_idx, 0, 0, 1);
		mat4 p_source = p_source_zero;
		p_source[2][0] = -eye_sep * source_idx;
		p_source[3][0] = -zero_parallax * eye_sep * source_idx;

		// get the current point's position in eye space
		vec4 pt_eye_coord = inverse(p_source) * vec4(2*texcoord.x-1, 2*texcoord.y-1, 2*pt_depth-1, 1);
		vec4 pos_eye = vec4(pt_eye_coord.xyz/pt_eye_coord.w,1);

		// calculate the intersection of the line from target view to the current point with the plane at z_far
		vec4 intersection_z_far = eye_target + (eye_target - pos_eye) * z_far / pos_eye.z;
		intersection_z_far.x -=  shear * (eye_target.x - eye_source.x);

		// calculate the intersection of the line from source view to the intersection at z_far with the plane at the current point's depth
		vec4 intersection_pt_depth = eye_source + (eye_source-intersection_z_far) * pos_eye.z / intersection_z_far.z;
		
		// reproject point to clip coordinates and calculate it's new window coordinates
		vec4 new_pos_clip = p_source * intersection_pt_depth;
		float x_window = 0.5*(new_pos_clip.x/new_pos_clip.w+1);

		// push elements to the back that are outside of the view's window to eliminate artefacts at leftmost and rightmost pixel columns
		pt_depth = (x_window<0 || x_window>1) ? 1 : pt_depth;

		// get the new position in coordinates [0,screen_width) with an offset depending on what view it is
		int new_pos_x = clamp(int(ceil((x_window+x_index) * screen_w - 1)),x_index*screen_w,(x_index+1)*screen_w-1);
		int index = new_pos_x+global_coord.y*screen_w*quilt_cols;
		
		int depth = int(pt_depth * 127);
		uint point = (depth << 25) | (int(color_bytes.a & 0x1)<<24) | (int(color_bytes.r) << 16) | (int(color_bytes.g) << 8) | int(color_bytes.b);
		uint old_point = col_depth[index];
		// early depth test
		if(old_point > point){
			// use atomicMin to keep the value with the smallest depth (z-buffer alternative)
			atomicMin(col_depth[index],point);
		}
	}
}
