#version 460 core

in vec2 texcoord;

uniform sampler2D color_tex;
uniform sampler2D depth_tex;

uniform mat4 p_source;

uniform vec4 eye_source;	// positino of source view in eye coordinates
uniform vec4 eye_target;	// position of target view in eye coordinates

uniform float z_far;		// depth at the z-far plane
uniform float shear;		// offset due to shear of the different projection matrices

out float discard_fs;
out vec4 color_fs;
out vec4 pos_eye;
out vec3 direction_fs;

void main()
{  	
	// get depth and color information and ensure that incorrect geometry will be discarded in the fragment shader
	float pt_depth = textureLod(depth_tex, texcoord, 0).r;
	discard_fs = pt_depth < 1 ? 0 : 1;
	color_fs = textureLod(color_tex, texcoord, 0);

	// calculate eye coordinates of current pixel
	vec4 pt_eye_coord = inverse(p_source) * vec4(2*texcoord.s-1, 2*texcoord.t-1, 2*pt_depth-1, 1);
	pos_eye = vec4(pt_eye_coord.xyz/pt_eye_coord.w,1);

	// direction from source view to the pixel --> needed to discard rubber-sheets in fragment shader
	direction_fs = normalize(eye_source.xyz - pos_eye.xyz);

	// calculate intersection of ray from target view to current pixel and the plane at z_far
	vec4 intersection_z_far = eye_target + (eye_target - pos_eye) * z_far / pos_eye.z;
	intersection_z_far.x -= shear;

	// calculate intersection of ray from source view to intersection at z_far with the plane at the current pixel's depth
	vec4 intersection_pt_depth = eye_source + (eye_source-intersection_z_far) * pos_eye.z / intersection_z_far.z;

	// project the new position back to clip space
	vec4 new_pos_clip = p_source * intersection_pt_depth;

	// clip the position and asign new x-coordinate to the position
	gl_Position = vec4(new_pos_clip.x/new_pos_clip.w, 2*texcoord.t-1, 2*pt_depth-1, 1);
}
