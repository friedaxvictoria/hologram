#version 460 core

in VS_OUT {
	 vec2 texcoord_gs;
} gs_in[]; 

layout (triangles, invocations = 4) in;
layout (triangle_strip, max_vertices = 9) out;

uniform sampler2D color_tex0;
uniform sampler2D depth_tex0;
uniform sampler2D color_tex1;
uniform sampler2D depth_tex1;
uniform sampler2D color_tex2;
uniform sampler2D depth_tex2;

// distance between stereo eyes
uniform float current_target_eye;
uniform float x_offset;

uniform mat4 p_source_zero;

uniform uint nr_render_views;
uniform float start_x;

uniform float z_far;
uniform float shear;
uniform float eye_sep;
uniform float zero_parallax;

out float discard_fs;
out vec4 color_fs;
out vec4 pos_eye;
out vec3 direction_fs;

void main()
{
	vec4 eye_target = vec4(current_target_eye + gl_InvocationID*x_offset, 0, 0, 1);

	vec4 color;
	float pt_depth;

	for (int i = 0; i<3; i++){
		for (int j = 0; j < nr_render_views; j++){
			float source_idx = nr_render_views == 1 ? 0.0 : (2.0f * j) / (nr_render_views - 1) - 1.0f;
			vec4 eye_source = vec4(- start_x * source_idx, 0, 0, 1);
			mat4 p_source = p_source_zero;
			p_source[2][0] = -eye_sep * source_idx;
			p_source[3][0] = -zero_parallax * eye_sep * source_idx;

			if (j == 0){
				color = textureLod(color_tex0, gs_in[i].texcoord_gs, 0);
				pt_depth = textureLod(depth_tex0, gs_in[i].texcoord_gs, 0).r;
			}
			else if (j==1){
				color = textureLod(color_tex1, gs_in[i].texcoord_gs, 0);
				pt_depth = textureLod(depth_tex1, gs_in[i].texcoord_gs, 0).r;
			}
			else{
				color = textureLod(color_tex2, gs_in[i].texcoord_gs, 0);
				pt_depth = textureLod(depth_tex2, gs_in[i].texcoord_gs, 0).r;
			}

			color_fs = color;
			discard_fs = pt_depth < 1 ? 0 : 1;

			// calculate eye coordinates of current point
			vec4 pt_eye_coord = inverse(p_source) * vec4(2*gs_in[i].texcoord_gs.s-1, 2*gs_in[i].texcoord_gs.t-1, 2*pt_depth-1, 1);
			pos_eye = vec4(pt_eye_coord.xyz/pt_eye_coord.w,1);

			// direction from source view to the point --> needed to discard rubber-sheets
			direction_fs = normalize(eye_source.xyz - pos_eye.xyz);

			// calculate intersection of line from target view to current point and the plane at z_far
			vec4 intersection_z_far = eye_target + (eye_target - pos_eye) * z_far / pos_eye.z;
			intersection_z_far.x -=  shear * (eye_target.x - eye_source.x);

			// calculate intersection of line from source view to intersection at z_far with the plane at the current point's depth
			vec4 intersection_pt_depth = eye_source + (eye_source-intersection_z_far) * pos_eye.z / intersection_z_far.z;

			// project the new position back to clip space
			vec4 new_pos_clip = p_source * intersection_pt_depth;

			gl_Position = vec4(new_pos_clip.x/new_pos_clip.w, 2*gs_in[i].texcoord_gs.t-1, 2*pt_depth-1, 1);

			// set layer and viewport index for volume or quilt variant
			gl_Layer = gl_InvocationID;
			gl_ViewportIndex = gl_InvocationID;

			EmitVertex();
		}
	}
	EndPrimitive(); 
}