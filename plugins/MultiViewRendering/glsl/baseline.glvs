#version 460 core

/***** begin interface of view.glsl ***********************************/
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
/***** end interface of view.glsl ***********************************/

uniform sampler2D color;
uniform sampler2D depth;

uniform mat4 inv_proj_source;
uniform mat4 modelview_source;

in vec4 position;
in vec2 texcoord;

out vec4 color_fs;
out float discard_fs;
out vec3 direction_fs;
out vec4 pos_source_world;


void main()
{
	color_fs = textureLod(color, texcoord,0);	// textureLod does not determine mip levels itself and is thus
	                                            // a bit faster than texture().

	float depth = textureLod(depth, texcoord, 0).r;
	discard_fs = depth < 1 ? 0 : 1; // make sure we see a non-zero value in the fragment shader whenever we have bad geometry

	// caluculate the projection direction based off of the pixel coordinates
	vec4 proj_on_znear = inverse(modelview_source) * inv_proj_source * vec4(position.x, position.y, -1, 1);
	vec4 proj_on_zfar = inverse(modelview_source) * inv_proj_source * vec4(position.x, position.y, 1, 1);
	direction_fs = normalize(proj_on_zfar.xyz - proj_on_znear.xyz);
	
	//float znear_w = -inv_proj_source[2][3] + inv_proj_source[3][3],
	//      zfar_w = inv_proj_source[2][3] + inv_proj_source[3][3];
	
	//float z_near  = (-inv_proj_source[2][2] + inv_proj_source[3][2])/znear_w, // divide by znear_w for non-orthogonal projections
	//      z_far   = (inv_proj_source[2][2] + inv_proj_source[3][2])/zfar_w; // divide by  zfar_w for non-orthogonal projections

	//float z_coord = (1-depth)*(z_near-z_far);
	//vec4 z_dir = vec4(normalize(get_normal_matrix()*vec3(0, 0, 1)),  0);

	//vec4 pos_target = get_modelview_matrix() * position; 
	pos_source_world = inverse(modelview_source)*inv_proj_source*vec4(2*texcoord.s-1, 2*texcoord.t-1, 2*depth-1, 1);
	//pos_target -= z_dir * z_coord;             
	
	gl_Position = get_projection_matrix() * get_modelview_matrix() * pos_source_world + 0.0000001 * position;
}
