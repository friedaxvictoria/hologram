#version 460 core

/***** begin interface of view.glsl ***********************************/
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
/***** end interface of view.glsl ***********************************/

uniform sampler2D color;
uniform sampler2D depth;

uniform mat4 inv_proj_source;
uniform mat4 modelview_source;
uniform float x_start;
uniform float y_start;
uniform float x_divide;
uniform float y_divide;

in vec4 position;
in vec2 texcoord;

out vec4 color_fs;
out float discard_fs;
out vec3 direction_fs;
out vec4 pos_source_world;


void main()
{
	vec2 texcoord_offset = vec2(x_start + texcoord.x/x_divide, y_start + texcoord.y/y_divide);
	color_fs = textureLod(color, texcoord_offset,0);

	float depth = textureLod(depth, texcoord_offset, 0).r;
	discard_fs = depth < 1 ? 0 : 1; // make sure we see a non-zero value in the fragment shader whenever we have bad geometry

	// caluculate the projection direction based off of the pixel coordinates
	vec4 proj_on_znear = inverse(modelview_source) * inv_proj_source * vec4(2*texcoord_offset.s-1, 2*texcoord_offset.t-1, -1, 1);
	vec4 proj_on_zfar = inverse(modelview_source) * inv_proj_source * vec4(2*texcoord_offset.s-1, 2*texcoord_offset.t-1, 1, 1);
	direction_fs = normalize(proj_on_zfar.xyz - proj_on_znear.xyz);
	
	pos_source_world = inverse(modelview_source)*inv_proj_source*vec4(2*texcoord_offset.s-1, 2*texcoord_offset.t-1, 2*depth-1, 1);
	
	gl_Position = get_projection_matrix() * get_modelview_matrix() * pos_source_world + 0.0000001 * position;
}
