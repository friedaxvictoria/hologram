#version 460 core

/***** begin interface of view.glsl ***********************************/
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
/***** end interface of view.glsl ***********************************/

uniform sampler2D color;
uniform sampler2D depth;

//uniform mat3 p_2;
//uniform mat3 p_1;
uniform mat4 inv_mvp_source;
uniform float screen_width;

uniform vec3 eye_source;
uniform vec3 eye_target;

uniform vec3 plane_normal;
uniform vec3 point_on_plane;

//uniform float fac;

in vec2 texcoord;

out vec4 color_fs;
out float discard_fs;

void main()
{  	
	/*float pt_depth = textureLod(depth, texcoord, 0).r;

	vec4 pt_world_coord = inv_mvp_source * vec4(2*texcoord.s-1, 2*texcoord.s-1, 2*pt_depth-1, 1);

	float range_value = length(vec4(eye_source,1) - pt_world_coord);

	float disparity = length(p_1*vec3(texcoord, 1))/range_value;

	//original equation but potentially p_2 == p_1 --> cancel each other out
	//float target_x = disparity * w/(r-l) * (eye_source-eye_target).x * fac + texcoord.x;
	vec3 target = disparity * inverse(p_2) * (eye_source-eye_target) + inverse(p_2) * p_1 * vec3(texcoord, 1);

	float depth = textureLod(depth, vec2(target.x, texcoord.y), 0).r;
	discard_fs = depth < 1 ? 0 : 1;

	color_fs = textureLod(color, vec2(target.x, texcoord.y), 0);
	//color_fs = vec4(range_value, range_value, range_value, 1);

	//vec4 position_transformed = get_modelview_projection_matrix() * position;
	//gl_Position = vec4(target.x, target.y, 2*depth-1, 1);
	//gl_Position = vec4(position_transformed.xy, 2*depth-1, position_transformed.w);
	gl_Position = vec4(2*texcoord.x-1, 2*texcoord.y-1, 2*depth-1, 1);
	//gl_Position = position_transformed;*/

	float pt_depth = textureLod(depth, texcoord, 0).r;
	vec4 pt_world_coord = inv_mvp_source * vec4(2*texcoord.s-1, 2*texcoord.s-1, 2*pt_depth-1, 1);
	vec3 pt_world_coord_clip = pt_world_coord.xyz/pt_world_coord.w;

	vec3 eye_to_point = eye_source - pt_world_coord_clip;
	float range_value = length(eye_to_point);

	float intersection_param = dot((point_on_plane-eye_source),plane_normal) / (dot(eye_to_point, plane_normal));
	vec3 intersection = eye_source + intersection_param * eye_to_point;

	float length_pt_plane = length(pt_world_coord_clip - intersection);

	float eye_distance = (eye_target-eye_source).x;

	float x_offset = eye_distance/range_value*length_pt_plane;
	vec4 x_offset_trans = inverse(inv_mvp_source) * vec4(x_offset,0,point_on_plane.z,1);
	float x_offset_clip = x_offset_trans.x/x_offset_trans.w;
	float x_offset_window = (0.5*(x_offset_clip+1))/screen_width;

	vec2 new_texcoord = vec2(texcoord.s+x_offset_window, texcoord.t);

	color_fs = textureLod(color, new_texcoord, 0);

	float new_depth = textureLod(depth, new_texcoord, 0).r;
	discard_fs = new_depth < 1 ? 0 : 1;

	gl_Position = vec4(2*texcoord.s-1, 2*texcoord.t-1, 2*new_depth-1, 1);
}
